{
  "version": 3,
  "sources": ["../../three/examples/jsm/loaders/DDSLoader.js"],
  "sourcesContent": ["import {\n\tCompressedTextureLoader,\n\tRGBAFormat,\n\tRGBA_S3TC_DXT3_Format,\n\tRGBA_S3TC_DXT5_Format,\n\tRGB_ETC1_Format,\n\tRGB_S3TC_DXT1_Format,\n\tRGB_BPTC_SIGNED_Format,\n\tRGB_BPTC_UNSIGNED_Format\n} from 'three';\n\n/**\n * A loader for the S3TC texture compression format.\n *\n * ```js\n * const loader = new DDSLoader();\n *\n * const map = loader.load( 'textures/compressed/disturb_dxt1_nomip.dds' );\n * map.colorSpace = THREE.SRGBColorSpace; // only for color textures\n * ```\n *\n * @augments CompressedTextureLoader\n * @three_import import { DDSLoader } from 'three/addons/loaders/DDSLoader.js';\n */\nclass DDSLoader extends CompressedTextureLoader {\n\n\t/**\n\t * Constructs a new DDS loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\t/**\n\t * Parses the given S3TC texture data.\n\t *\n\t * @param {ArrayBuffer} buffer - The raw texture data.\n\t * @param {boolean} loadMipmaps - Whether to load mipmaps or not.\n\t * @return {CompressedTextureLoader~TexData} An object representing the parsed texture data.\n\t */\n\tparse( buffer, loadMipmaps ) {\n\n\t\tconst dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };\n\n\t\t// Adapted from @toji's DDS utils\n\t\t// https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js\n\n\t\t// All values and structures referenced from:\n\t\t// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\n\n\t\tconst DDS_MAGIC = 0x20534444;\n\n\t\t// const DDSD_CAPS = 0x1;\n\t\t// const DDSD_HEIGHT = 0x2;\n\t\t// const DDSD_WIDTH = 0x4;\n\t\t// const DDSD_PITCH = 0x8;\n\t\t// const DDSD_PIXELFORMAT = 0x1000;\n\t\tconst DDSD_MIPMAPCOUNT = 0x20000;\n\t\t// const DDSD_LINEARSIZE = 0x80000;\n\t\t// const DDSD_DEPTH = 0x800000;\n\n\t\t// const DDSCAPS_COMPLEX = 0x8;\n\t\t// const DDSCAPS_MIPMAP = 0x400000;\n\t\t// const DDSCAPS_TEXTURE = 0x1000;\n\n\t\tconst DDSCAPS2_CUBEMAP = 0x200;\n\t\tconst DDSCAPS2_CUBEMAP_POSITIVEX = 0x400;\n\t\tconst DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800;\n\t\tconst DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000;\n\t\tconst DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000;\n\t\tconst DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000;\n\t\tconst DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000;\n\t\t// const DDSCAPS2_VOLUME = 0x200000;\n\n\t\t// const DDPF_ALPHAPIXELS = 0x1;\n\t\t// const DDPF_ALPHA = 0x2;\n\t\t// const DDPF_FOURCC = 0x4;\n\t\t// const DDPF_RGB = 0x40;\n\t\t// const DDPF_YUV = 0x200;\n\t\t// const DDPF_LUMINANCE = 0x20000;\n\n\t\tconst DXGI_FORMAT_BC6H_UF16 = 95;\n\t\tconst DXGI_FORMAT_BC6H_SF16 = 96;\n\n\t\tfunction fourCCToInt32( value ) {\n\n\t\t\treturn value.charCodeAt( 0 ) +\n\t\t\t\t( value.charCodeAt( 1 ) << 8 ) +\n\t\t\t\t( value.charCodeAt( 2 ) << 16 ) +\n\t\t\t\t( value.charCodeAt( 3 ) << 24 );\n\n\t\t}\n\n\t\tfunction int32ToFourCC( value ) {\n\n\t\t\treturn String.fromCharCode(\n\t\t\t\tvalue & 0xff,\n\t\t\t\t( value >> 8 ) & 0xff,\n\t\t\t\t( value >> 16 ) & 0xff,\n\t\t\t\t( value >> 24 ) & 0xff\n\t\t\t);\n\n\t\t}\n\n\t\tfunction loadARGBMip( buffer, dataOffset, width, height ) {\n\n\t\t\tconst dataLength = width * height * 4;\n\t\t\tconst srcBuffer = new Uint8Array( buffer, dataOffset, dataLength );\n\t\t\tconst byteArray = new Uint8Array( dataLength );\n\t\t\tlet dst = 0;\n\t\t\tlet src = 0;\n\t\t\tfor ( let y = 0; y < height; y ++ ) {\n\n\t\t\t\tfor ( let x = 0; x < width; x ++ ) {\n\n\t\t\t\t\tconst b = srcBuffer[ src ]; src ++;\n\t\t\t\t\tconst g = srcBuffer[ src ]; src ++;\n\t\t\t\t\tconst r = srcBuffer[ src ]; src ++;\n\t\t\t\t\tconst a = srcBuffer[ src ]; src ++;\n\t\t\t\t\tbyteArray[ dst ] = r; dst ++;\t//r\n\t\t\t\t\tbyteArray[ dst ] = g; dst ++;\t//g\n\t\t\t\t\tbyteArray[ dst ] = b; dst ++;\t//b\n\t\t\t\t\tbyteArray[ dst ] = a; dst ++;\t//a\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn byteArray;\n\n\t\t}\n\n\t\tfunction loadRGBMip( buffer, dataOffset, width, height ) {\n\n\t\t\tconst dataLength = width * height * 3;\n\t\t\tconst srcBuffer = new Uint8Array( buffer, dataOffset, dataLength );\n\t\t\tconst byteArray = new Uint8Array( width * height * 4 );\n\t\t\tlet dst = 0;\n\t\t\tlet src = 0;\n\t\t\tfor ( let y = 0; y < height; y ++ ) {\n\n\t\t\t\tfor ( let x = 0; x < width; x ++ ) {\n\n\t\t\t\t\tconst b = srcBuffer[ src ]; src ++;\n\t\t\t\t\tconst g = srcBuffer[ src ]; src ++;\n\t\t\t\t\tconst r = srcBuffer[ src ]; src ++;\n\t\t\t\t\tbyteArray[ dst ] = r; dst ++;\t//r\n\t\t\t\t\tbyteArray[ dst ] = g; dst ++;\t//g\n\t\t\t\t\tbyteArray[ dst ] = b; dst ++;\t//b\n\t\t\t\t\tbyteArray[ dst ] = 255; dst ++; //a\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn byteArray;\n\n\t\t}\n\n\t\tconst FOURCC_DXT1 = fourCCToInt32( 'DXT1' );\n\t\tconst FOURCC_DXT3 = fourCCToInt32( 'DXT3' );\n\t\tconst FOURCC_DXT5 = fourCCToInt32( 'DXT5' );\n\t\tconst FOURCC_ETC1 = fourCCToInt32( 'ETC1' );\n\t\tconst FOURCC_DX10 = fourCCToInt32( 'DX10' );\n\n\t\tconst headerLengthInt = 31; // The header length in 32 bit ints\n\t\tconst extendedHeaderLengthInt = 5; // The extended header length in 32 bit ints\n\n\t\t// Offsets into the header array\n\n\t\tconst off_magic = 0;\n\n\t\tconst off_size = 1;\n\t\tconst off_flags = 2;\n\t\tconst off_height = 3;\n\t\tconst off_width = 4;\n\n\t\tconst off_mipmapCount = 7;\n\n\t\t// const off_pfFlags = 20;\n\t\tconst off_pfFourCC = 21;\n\t\tconst off_RGBBitCount = 22;\n\t\tconst off_RBitMask = 23;\n\t\tconst off_GBitMask = 24;\n\t\tconst off_BBitMask = 25;\n\t\tconst off_ABitMask = 26;\n\n\t\t// const off_caps = 27;\n\t\tconst off_caps2 = 28;\n\t\t// const off_caps3 = 29;\n\t\t// const off_caps4 = 30;\n\n\t\t// If fourCC = DX10, the extended header starts after 32\n\t\tconst off_dxgiFormat = 0;\n\n\t\t// Parse header\n\n\t\tconst header = new Int32Array( buffer, 0, headerLengthInt );\n\n\t\tif ( header[ off_magic ] !== DDS_MAGIC ) {\n\n\t\t\tconsole.error( 'THREE.DDSLoader.parse: Invalid magic number in DDS header.' );\n\t\t\treturn dds;\n\n\t\t}\n\n\t\tlet blockBytes;\n\n\t\tconst fourCC = header[ off_pfFourCC ];\n\n\t\tlet isRGBAUncompressed = false;\n\t\tlet isRGBUncompressed = false;\n\n\t\tlet dataOffset = header[ off_size ] + 4;\n\n\t\tswitch ( fourCC ) {\n\n\t\t\tcase FOURCC_DXT1:\n\n\t\t\t\tblockBytes = 8;\n\t\t\t\tdds.format = RGB_S3TC_DXT1_Format;\n\t\t\t\tbreak;\n\n\t\t\tcase FOURCC_DXT3:\n\n\t\t\t\tblockBytes = 16;\n\t\t\t\tdds.format = RGBA_S3TC_DXT3_Format;\n\t\t\t\tbreak;\n\n\t\t\tcase FOURCC_DXT5:\n\n\t\t\t\tblockBytes = 16;\n\t\t\t\tdds.format = RGBA_S3TC_DXT5_Format;\n\t\t\t\tbreak;\n\n\t\t\tcase FOURCC_ETC1:\n\n\t\t\t\tblockBytes = 8;\n\t\t\t\tdds.format = RGB_ETC1_Format;\n\t\t\t\tbreak;\n\n\t\t\tcase FOURCC_DX10:\n\n\t\t\t\tdataOffset += extendedHeaderLengthInt * 4;\n\t\t\t\tconst extendedHeader = new Int32Array( buffer, ( headerLengthInt + 1 ) * 4, extendedHeaderLengthInt );\n\t\t\t\tconst dxgiFormat = extendedHeader[ off_dxgiFormat ];\n\t\t\t\tswitch ( dxgiFormat ) {\n\n\t\t\t\t\tcase DXGI_FORMAT_BC6H_SF16: {\n\n\t\t\t\t\t\tblockBytes = 16;\n\t\t\t\t\t\tdds.format = RGB_BPTC_SIGNED_Format;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcase DXGI_FORMAT_BC6H_UF16: {\n\n\t\t\t\t\t\tblockBytes = 16;\n\t\t\t\t\t\tdds.format = RGB_BPTC_UNSIGNED_Format;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdefault: {\n\n\t\t\t\t\t\tconsole.error( 'THREE.DDSLoader.parse: Unsupported DXGI_FORMAT code ', dxgiFormat );\n\t\t\t\t\t\treturn dds;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tif ( header[ off_RGBBitCount ] === 32\n\t\t\t\t\t&& header[ off_RBitMask ] & 0xff0000\n\t\t\t\t\t&& header[ off_GBitMask ] & 0xff00\n\t\t\t\t\t&& header[ off_BBitMask ] & 0xff\n\t\t\t\t\t&& header[ off_ABitMask ] & 0xff000000 ) {\n\n\t\t\t\t\tisRGBAUncompressed = true;\n\t\t\t\t\tblockBytes = 64;\n\t\t\t\t\tdds.format = RGBAFormat;\n\n\t\t\t\t} else if ( header[ off_RGBBitCount ] === 24\n\t\t\t\t\t&& header[ off_RBitMask ] & 0xff0000\n\t\t\t\t\t&& header[ off_GBitMask ] & 0xff00\n\t\t\t\t\t&& header[ off_BBitMask ] & 0xff ) {\n\n\t\t\t\t    \tisRGBUncompressed = true;\n                    \t\t\tblockBytes = 64;\n                    \t\t\tdds.format = RGBAFormat;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.DDSLoader.parse: Unsupported FourCC code ', int32ToFourCC( fourCC ) );\n\t\t\t\t\treturn dds;\n\n\t\t\t\t}\n\n\t\t}\n\n\t\tdds.mipmapCount = 1;\n\n\t\tif ( header[ off_flags ] & DDSD_MIPMAPCOUNT && loadMipmaps !== false ) {\n\n\t\t\tdds.mipmapCount = Math.max( 1, header[ off_mipmapCount ] );\n\n\t\t}\n\n\t\tconst caps2 = header[ off_caps2 ];\n\t\tdds.isCubemap = caps2 & DDSCAPS2_CUBEMAP ? true : false;\n\t\tif ( dds.isCubemap && (\n\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEX ) ||\n\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX ) ||\n\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEY ) ||\n\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY ) ||\n\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ ) ||\n\t\t\t! ( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ )\n\t\t) ) {\n\n\t\t\tconsole.error( 'THREE.DDSLoader.parse: Incomplete cubemap faces' );\n\t\t\treturn dds;\n\n\t\t}\n\n\t\tdds.width = header[ off_width ];\n\t\tdds.height = header[ off_height ];\n\n\t\t// Extract mipmaps buffers\n\n\t\tconst faces = dds.isCubemap ? 6 : 1;\n\n\t\tfor ( let face = 0; face < faces; face ++ ) {\n\n\t\t\tlet width = dds.width;\n\t\t\tlet height = dds.height;\n\n\t\t\tfor ( let i = 0; i < dds.mipmapCount; i ++ ) {\n\n\t\t\t\tlet byteArray, dataLength;\n\n\t\t\t\tif ( isRGBAUncompressed ) {\n\n\t\t\t\t\tbyteArray = loadARGBMip( buffer, dataOffset, width, height );\n\t\t\t\t\tdataLength = byteArray.length;\n\n\t\t\t\t} else if ( isRGBUncompressed ) {\n\n\t\t\t\t\tbyteArray = loadRGBMip( buffer, dataOffset, width, height );\n\t\t\t\t\tdataLength = width * height * 3;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdataLength = Math.max( 4, width ) / 4 * Math.max( 4, height ) / 4 * blockBytes;\n\t\t\t\t\tbyteArray = new Uint8Array( buffer, dataOffset, dataLength );\n\n\t\t\t\t}\n\n\t\t\t\tconst mipmap = { 'data': byteArray, 'width': width, 'height': height };\n\t\t\t\tdds.mipmaps.push( mipmap );\n\n\t\t\t\tdataOffset += dataLength;\n\n\t\t\t\twidth = Math.max( width >> 1, 1 );\n\t\t\t\theight = Math.max( height >> 1, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn dds;\n\n\t}\n\n}\n\nexport { DDSLoader };\n"],
  "mappings": "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",
  "names": ["buffer", "dataOffset"]
}
